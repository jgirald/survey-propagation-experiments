La introducción debe responder cuestiones fundamentales: motivación y objetivos. La motivación debe explicar porque nos interesa resolver SAT (y explicar el problema) y porque aparecen métodos aproximados (como SP) para resolver SAT en lugar de métodos exactos/completos (debido a que SAT es NP-completo y por tanto, en el peor caso requiere un tiempo exponencial con los algoritmos conocidos). Además, y más concretamente sobre SP, la motivación debe hablar de que SP es el método que resuelve las fórmulas SAT más difíciles que conocemos (fórmulas aleatorias cerca del punto de transición de fase, y de gran tamaño que ningún otro método ha sido capaz de resolver), pero que falla al intentar resolver fórmulas industriales. En los objetivos habría que comentar lo que te dije antes: "entender el porqué".

# Introduction

The boolean satisfiability problem (SAT) is the combinatorial discrete optimization problem of determining if an interpretation that satisfies a boolean formula exists. The formula is satisfied if there exists at least one set of variables assignments that causes the formula to evaluate to true. The SAT problem is central in Computer Science for two main reasons: It was the first problem to be proved NP-complete and it has many industrial application such as planning, cryptography or scheduling, among others, because this domains can be encoded in a boolean formula and solved with SAT algorithms. By convention, SAT problems are encoded to conjuntive normal form (CNF): a product of sums of literals, where a literal is a boolean variable or its negation, a clause is a disjunction (logical OR) of literals, and the product is a conjunction (logical AND) of all the clauses. The problem can be restricted in many ways, being the focus of the work on the 3-SAT problem, where each clause of the formula is limited to maximum three literals.

Real-life SAT instances involve thousands of variables and clauses in a non-random way which share a common structure. This differs from the random generated formulas used to benchmark the differents aproaches that have been developed. In the first place, complete methods were use to test satisfiability with the guarantee that the algorithm will terminate with a correct result determining if a formula is satisfiable or not. Such methods include successively eliminate variables of the CNF without changing its satisfiability, successively apply inference rules until a contradiction is found or the CNF is closed or sistematic search in the space of truth assignments among others. Algthough this last method has received a lot of attetion due to its efficiency and versatility on real-world problems, the NP-complete nature of the problem, which causes the worst case to require exponential time, has forced to use incomplete methods to save time and resources. An incomplete method do not provide the guarantee to found if the CNF is satisfiable or not. Is in this methods where Survey Propagation (SP) is included. SP is so far the only known method that successfully solve random 3-SAT instances with more that one million variables in almost linear time in the critical constrained region. The heuristic used by SP (derived from the statistical physics cavity method) is almost always correct, which avoids the need of the method to need backtracking and be able to calculate marginal probabilities to assign values to variables in an iterative process of simplifing the formula.

This success of SP on 3-SAT instances has atracted a lot of atention which had led to a focus research on understanding various aspects of SP. Many of this aspects are still unclear and it's why the objectives of this Final Master Project observe the difference of SP on solving random and real-world instances of 3-SAT to understand why SP fails to solve real-world instances.

In the next section we briefly describe the theoretical fundaments and nomenclature used in this work, as well as the different CNF generators used. Section 3 will be the state of the art with focus on incomplete methods. In depth description of SP and the modern implementation in C++ developed of it is done in section 4, followed by the experimental analisis and the conclusions.
